use std::{collections::BTreeMap, fs, net::SocketAddr, path::Path};

use anyhow::Context;
use serde::{Deserialize, Serialize};
use url::Url;

use crate::protocol::de_null_as_default;

fn default_logging_filter() -> String {
  "info".to_string()
}

fn default_thinking_enabled() -> bool {
  true
}

fn default_thinking_budget_tokens() -> u32 {
  10000
}

fn default_max_tokens() -> u32 {
  8192
}

fn default_timeout_seconds() -> u64 {
  120
}

fn default_history_summary_max_tokens() -> u32 {
  1024
}

fn default_history_summary_timeout_seconds() -> u64 {
  60
}

fn default_history_summary_trigger_on_history_size_chars() -> usize {
  800_000
}

fn default_history_summary_history_tail_size_chars_to_exclude() -> usize {
  250_000
}

fn default_history_summary_min_tail_exchanges() -> usize {
  2
}

fn default_history_summary_cache_ttl_ms() -> u64 {
  0
}

fn default_history_summary_max_summarization_input_chars() -> usize {
  250_000
}

fn default_history_summary_prompt() -> String {
  r#"You are performing a CONTEXT CHECKPOINT COMPACTION. Create a handoff summary for another LLM that will resume the task.

Include:
- Current progress and key decisions made
- Important context, constraints, or user preferences
- What remains to be done (clear next steps)
- Any critical data, examples, or references needed to continue
- Key tool invocations (with tool name and brief input/output summary)
- Important errors or issues encountered and their resolutions
- Critical file modifications (which files were changed and why)

For tool invocations, summarize the tool name and what was accomplished. For file modifications, note the file path and purpose of the change.

Be concise, structured, and focused on helping the next LLM seamlessly continue the work. If you are unsure about any past step or tool result, explicitly say so instead of guessing."#
    .to_string()
}

fn default_history_summary_trigger_strategy() -> String {
  "auto".to_string()
}

fn default_history_summary_trigger_on_context_ratio() -> f32 {
  0.60
}

fn default_history_summary_target_context_ratio() -> f32 {
  0.45
}

fn default_history_summary_min_delta_exchanges_to_keep() -> usize {
  3
}

fn default_history_summary_rolling_fallback_threshold() -> f32 {
  0.80
}

fn default_history_summary_bytes_per_token_estimate() -> f32 {
  4.0
}

fn is_valid_history_summary_template_new_mode(template: &str) -> bool {
  let required = [
    "{summary}",
    "{summarization_request_id}",
    "{beginning_part_dropped_num_exchanges}",
    "{middle_part_abridged}",
    "{end_part_full}",
  ];
  required.iter().all(|p| template.contains(p))
}

fn default_history_summary_template() -> String {
  r#"
<supervisor>
This is a continuation of the conversation that Agent(you) had with the user.

Here is the summary of whole conversation history that was generated by Agent(you) so 'I' in the summary represents Agent(you).
<summary request_id="{summarization_request_id}">
{summary}
</summary>

The whole previous conversation history was split into three parts:
- beginning. Information from this part is only present in the compressed form in the summary above. This part is not shown neither in abridged nor in full form below to reduce context size. This part can be empty if the whole conversation was short enough.
- middle. This part is present in the abridged form below.
- end. This part is present in full form below.

Beginning part has {beginning_part_dropped_num_exchanges} exchanges.

<middle_part_abridged>
{middle_part_abridged}
</middle_part_abridged>

<end_part_full>
{end_part_full}
</end_part_full>

Continue the conversation and finish the task given by the user from this point.
</supervisor>"#
    .trim()
    .to_string()
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Config {
  pub server: ServerConfig,
  pub proxy: ProxyConfig,
  pub official: OfficialConfig,
  pub byok: ByokConfig,
  #[serde(default)]
  pub history_summary: HistorySummaryConfig,
  #[serde(default)]
  pub logging: LoggingConfig,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ServerConfig {
  pub host: String,
  pub port: u16,
}

impl ServerConfig {
  pub fn socket_addr(&self) -> anyhow::Result<SocketAddr> {
    let addr: SocketAddr = format!("{}:{}", self.host, self.port)
      .parse()
      .context("server.host/server.port 不是合法 socket 地址")?;
    Ok(addr)
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ProxyConfig {
  pub auth_token: String,
}

impl ProxyConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.auth_token.trim().is_empty() {
      anyhow::bail!("proxy.auth_token 不能为空");
    }
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct OfficialConfig {
  pub base_url: String,
  pub api_token: String,
}

impl OfficialConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.base_url.trim().is_empty() {
      anyhow::bail!("official.base_url 不能为空");
    }
    if self.api_token.trim().is_empty() {
      anyhow::bail!("official.api_token 不能为空");
    }
    let _ = Url::parse(&self.base_url).context("official.base_url 不是合法 URL")?;
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ByokConfig {
  pub providers: Vec<ProviderConfig>,
  #[serde(default)]
  pub active_provider_id: Option<String>,
}

impl ByokConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.providers.is_empty() {
      anyhow::bail!("byok.providers 不能为空");
    }

    let mut seen_ids: std::collections::HashSet<String> = std::collections::HashSet::new();
    for p in &self.providers {
      p.validate()?;
      let id = p.id().trim();
      if id.is_empty() {
        anyhow::bail!("byok.providers[].id 不能为空");
      }
      if id.contains(':') {
        anyhow::bail!(
          "byok.providers[].id 不能包含 ':'（会破坏 byok:<providerId>:<modelId> 解析）：{id}"
        );
      }
      if !seen_ids.insert(id.to_string()) {
        anyhow::bail!("byok.providers[].id 重复：{id}");
      }
    }
    if let Some(id) = &self.active_provider_id {
      let id = id.trim();
      if id.is_empty() {
        anyhow::bail!("byok.active_provider_id 不能为空字符串（或删除该字段）");
      }
      if !self.providers.iter().any(|p| p.id().trim() == id) {
        anyhow::bail!("byok.active_provider_id 未命中 providers: {id}");
      }
    }
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum ProviderConfig {
  #[serde(rename = "anthropic")]
  Anthropic(AnthropicProviderConfig),
  #[serde(
    rename = "openai_compatible",
    alias = "openai-compatible",
    alias = "openai"
  )]
  OpenAICompatible(OpenAICompatibleProviderConfig),
}

impl ProviderConfig {
  pub fn id(&self) -> &str {
    match self {
      ProviderConfig::Anthropic(p) => p.id.as_str(),
      ProviderConfig::OpenAICompatible(p) => p.id.as_str(),
    }
  }

  pub fn validate(&self) -> anyhow::Result<()> {
    match self {
      ProviderConfig::Anthropic(p) => p.validate(),
      ProviderConfig::OpenAICompatible(p) => p.validate(),
    }
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct AnthropicProviderConfig {
  pub id: String,
  pub base_url: String,
  pub api_key: String,
  pub default_model: String,
  #[serde(default = "default_max_tokens")]
  pub max_tokens: u32,
  #[serde(default = "default_timeout_seconds")]
  pub timeout_seconds: u64,
  #[serde(default)]
  pub thinking: ThinkingConfig,
  #[serde(default)]
  pub extra_headers: BTreeMap<String, String>,
}

impl AnthropicProviderConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.id.trim().is_empty() {
      anyhow::bail!("byok.providers[type=anthropic].id 不能为空");
    }
    if self.base_url.trim().is_empty() {
      anyhow::bail!("byok.providers[type=anthropic].base_url 不能为空");
    }
    if self.api_key.trim().is_empty() {
      anyhow::bail!("byok.providers[type=anthropic].api_key 不能为空");
    }
    if self.default_model.trim().is_empty() {
      anyhow::bail!("byok.providers[type=anthropic].default_model 不能为空");
    }
    let _ =
      Url::parse(&self.base_url).context("byok.providers[type=anthropic].base_url 不是合法 URL")?;
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct OpenAICompatibleProviderConfig {
  pub id: String,
  pub base_url: String,
  pub api_key: String,
  pub default_model: String,
  #[serde(default = "default_max_tokens")]
  pub max_tokens: u32,
  #[serde(default = "default_timeout_seconds")]
  pub timeout_seconds: u64,
  #[serde(default)]
  pub extra_headers: BTreeMap<String, String>,
}

impl OpenAICompatibleProviderConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.id.trim().is_empty() {
      anyhow::bail!("byok.providers[type=openai_compatible].id 不能为空");
    }
    if self.base_url.trim().is_empty() {
      anyhow::bail!("byok.providers[type=openai_compatible].base_url 不能为空");
    }
    if self.api_key.trim().is_empty() {
      anyhow::bail!("byok.providers[type=openai_compatible].api_key 不能为空");
    }
    if self.default_model.trim().is_empty() {
      anyhow::bail!("byok.providers[type=openai_compatible].default_model 不能为空");
    }
    let _ = Url::parse(&self.base_url)
      .context("byok.providers[type=openai_compatible].base_url 不是合法 URL")?;
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ThinkingConfig {
  #[serde(default = "default_thinking_enabled")]
  pub enabled: bool,
  #[serde(default = "default_thinking_budget_tokens")]
  pub budget_tokens: u32,
}

impl Default for ThinkingConfig {
  fn default() -> Self {
    Self {
      enabled: default_thinking_enabled(),
      budget_tokens: default_thinking_budget_tokens(),
    }
  }
}

impl Config {
  pub fn load(path: &Path) -> anyhow::Result<Self> {
    let bytes = fs::read(path).with_context(|| format!("读取配置失败: {}", path.display()))?;
    let config: Self =
      serde_yaml::from_slice(&bytes).context("解析 YAML 配置失败 (config.yaml)")?;
    config.validate()?;
    Ok(config)
  }

  pub fn save(&self, path: &Path) -> anyhow::Result<()> {
    let next = self.clone();
    next.validate()?;
    let yaml = serde_yaml::to_string(&next).context("序列化 YAML 配置失败")?;
    fs::write(path, yaml).with_context(|| format!("写入配置失败: {}", path.display()))?;
    Ok(())
  }

  pub fn validate(&self) -> anyhow::Result<()> {
    if self.server.host.trim().is_empty() {
      anyhow::bail!("server.host 不能为空");
    }
    if self.server.port == 0 {
      anyhow::bail!("server.port 不能为 0");
    }
    self.proxy.validate()?;
    self.official.validate()?;
    self.byok.validate()?;
    self.history_summary.validate(&self.byok)?;
    self.logging.validate()?;
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct HistorySummaryConfig {
  #[serde(default)]
  pub enabled: bool,
  #[serde(default, deserialize_with = "de_null_as_default")]
  pub provider_id: String,
  #[serde(default, deserialize_with = "de_null_as_default")]
  pub model: String,
  #[serde(default = "default_history_summary_max_tokens")]
  pub max_tokens: u32,
  #[serde(default = "default_history_summary_timeout_seconds")]
  pub timeout_seconds: u64,
  #[serde(default = "default_history_summary_trigger_on_history_size_chars")]
  pub trigger_on_history_size_chars: usize,
  #[serde(default = "default_history_summary_trigger_strategy")]
  pub trigger_strategy: String,
  #[serde(default = "default_history_summary_trigger_on_context_ratio")]
  pub trigger_on_context_ratio: f32,
  #[serde(default = "default_history_summary_target_context_ratio")]
  pub target_context_ratio: f32,
  #[serde(default)]
  pub context_window_tokens_default: u32,
  #[serde(default)]
  pub context_window_tokens_overrides: BTreeMap<String, u32>,
  #[serde(default = "default_history_summary_history_tail_size_chars_to_exclude")]
  pub history_tail_size_chars_to_exclude: usize,
  #[serde(default = "default_history_summary_min_tail_exchanges")]
  pub min_tail_exchanges: usize,
  #[serde(default = "default_history_summary_min_delta_exchanges_to_keep")]
  pub min_delta_exchanges_to_keep: usize,
  #[serde(default = "default_history_summary_rolling_fallback_threshold")]
  pub rolling_fallback_threshold: f32,
  #[serde(default = "default_history_summary_bytes_per_token_estimate")]
  pub bytes_per_token_estimate: f32,
  #[serde(default = "default_history_summary_cache_ttl_ms")]
  pub cache_ttl_ms: u64,
  #[serde(default = "default_history_summary_max_summarization_input_chars")]
  pub max_summarization_input_chars: usize,
  #[serde(default = "default_history_summary_prompt")]
  pub prompt: String,
  #[serde(default)]
  pub rolling_summary: bool,
  #[serde(default = "default_history_summary_template")]
  pub summary_node_request_message_template: String,
  #[serde(default)]
  pub abridged_history_params: AbridgedHistoryParams,
}

impl Default for HistorySummaryConfig {
  fn default() -> Self {
    Self {
      enabled: false,
      provider_id: String::new(),
      model: String::new(),
      max_tokens: default_history_summary_max_tokens(),
      timeout_seconds: default_history_summary_timeout_seconds(),
      trigger_on_history_size_chars: default_history_summary_trigger_on_history_size_chars(),
      trigger_strategy: default_history_summary_trigger_strategy(),
      trigger_on_context_ratio: default_history_summary_trigger_on_context_ratio(),
      target_context_ratio: default_history_summary_target_context_ratio(),
      context_window_tokens_default: 0,
      context_window_tokens_overrides: BTreeMap::new(),
      history_tail_size_chars_to_exclude:
        default_history_summary_history_tail_size_chars_to_exclude(),
      min_tail_exchanges: default_history_summary_min_tail_exchanges(),
      min_delta_exchanges_to_keep: default_history_summary_min_delta_exchanges_to_keep(),
      rolling_fallback_threshold: default_history_summary_rolling_fallback_threshold(),
      bytes_per_token_estimate: default_history_summary_bytes_per_token_estimate(),
      cache_ttl_ms: default_history_summary_cache_ttl_ms(),
      max_summarization_input_chars: default_history_summary_max_summarization_input_chars(),
      prompt: default_history_summary_prompt(),
      rolling_summary: true,
      summary_node_request_message_template: default_history_summary_template(),
      abridged_history_params: AbridgedHistoryParams::default(),
    }
  }
}

impl HistorySummaryConfig {
  pub fn validate(&self, byok: &ByokConfig) -> anyhow::Result<()> {
    if !self.enabled {
      return Ok(());
    }
    if !self.provider_id.trim().is_empty()
      && !byok
        .providers
        .iter()
        .any(|p| p.id().trim() == self.provider_id.trim())
    {
      anyhow::bail!(
        "history_summary.provider_id 未命中 byok.providers[].id: {}",
        self.provider_id.trim()
      );
    }
    if self.prompt.trim().is_empty() {
      anyhow::bail!(
        "history_summary.prompt 不能为空（用于生成 summary_text；可使用默认 Codex 风格 prompt）"
      );
    }
    if self.trigger_on_history_size_chars == 0 {
      anyhow::bail!("history_summary.trigger_on_history_size_chars 不能为 0（否则永远不会触发）");
    }
    let strategy = self.trigger_strategy.trim().to_ascii_lowercase();
    if strategy != "auto" && strategy != "chars" && strategy != "ratio" {
      anyhow::bail!("history_summary.trigger_strategy 仅支持 auto/chars/ratio");
    }
    if !(0.0..=1.0).contains(&self.trigger_on_context_ratio) || self.trigger_on_context_ratio <= 0.0
    {
      anyhow::bail!("history_summary.trigger_on_context_ratio 取值范围为 (0,1]");
    }
    if !(0.0..=1.0).contains(&self.target_context_ratio) || self.target_context_ratio <= 0.0 {
      anyhow::bail!("history_summary.target_context_ratio 取值范围为 (0,1]");
    }
    if self.target_context_ratio > self.trigger_on_context_ratio {
      anyhow::bail!(
        "history_summary.target_context_ratio 不能大于 trigger_on_context_ratio（否则无法收敛）"
      );
    }
    if self.min_tail_exchanges == 0 {
      anyhow::bail!("history_summary.min_tail_exchanges 不能为 0");
    }
    if self.min_delta_exchanges_to_keep == 0 {
      anyhow::bail!("history_summary.min_delta_exchanges_to_keep 不能为 0");
    }
    if !(0.0..=1.0).contains(&self.rolling_fallback_threshold) || self.rolling_fallback_threshold <= 0.0 {
      anyhow::bail!("history_summary.rolling_fallback_threshold 取值范围为 (0,1]");
    }
    if self.bytes_per_token_estimate <= 0.0 || self.bytes_per_token_estimate > 10.0 {
      anyhow::bail!("history_summary.bytes_per_token_estimate 取值范围为 (0,10]");
    }
    if self.summary_node_request_message_template.trim().is_empty() {
      anyhow::bail!("history_summary.summary_node_request_message_template 不能为空");
    }
    if !is_valid_history_summary_template_new_mode(&self.summary_node_request_message_template) {
      anyhow::bail!(
        "history_summary.summary_node_request_message_template 必须包含占位符：{{summary}} / {{summarization_request_id}} / {{beginning_part_dropped_num_exchanges}} / {{middle_part_abridged}} / {{end_part_full}}"
      );
    }
    self.abridged_history_params.validate()?;
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct AbridgedHistoryParams {
  #[serde(default = "default_abridged_total_chars_limit")]
  pub total_chars_limit: usize,
  #[serde(default = "default_abridged_user_message_chars_limit")]
  pub user_message_chars_limit: usize,
  #[serde(default = "default_abridged_agent_response_chars_limit")]
  pub agent_response_chars_limit: usize,
  #[serde(default = "default_abridged_action_chars_limit")]
  pub action_chars_limit: usize,
  #[serde(default = "default_abridged_num_files_modified_limit")]
  pub num_files_modified_limit: usize,
  #[serde(default = "default_abridged_num_files_created_limit")]
  pub num_files_created_limit: usize,
  #[serde(default = "default_abridged_num_files_deleted_limit")]
  pub num_files_deleted_limit: usize,
  #[serde(default = "default_abridged_num_files_viewed_limit")]
  pub num_files_viewed_limit: usize,
  #[serde(default = "default_abridged_num_terminal_commands_limit")]
  pub num_terminal_commands_limit: usize,
}

fn default_abridged_total_chars_limit() -> usize {
  15_000
}

fn default_abridged_user_message_chars_limit() -> usize {
  1_000
}

fn default_abridged_agent_response_chars_limit() -> usize {
  2_000
}

fn default_abridged_action_chars_limit() -> usize {
  200
}

fn default_abridged_num_files_modified_limit() -> usize {
  10
}

fn default_abridged_num_files_created_limit() -> usize {
  10
}

fn default_abridged_num_files_deleted_limit() -> usize {
  10
}

fn default_abridged_num_files_viewed_limit() -> usize {
  10
}

fn default_abridged_num_terminal_commands_limit() -> usize {
  10
}

impl Default for AbridgedHistoryParams {
  fn default() -> Self {
    Self {
      total_chars_limit: default_abridged_total_chars_limit(),
      user_message_chars_limit: default_abridged_user_message_chars_limit(),
      agent_response_chars_limit: default_abridged_agent_response_chars_limit(),
      action_chars_limit: default_abridged_action_chars_limit(),
      num_files_modified_limit: default_abridged_num_files_modified_limit(),
      num_files_created_limit: default_abridged_num_files_created_limit(),
      num_files_deleted_limit: default_abridged_num_files_deleted_limit(),
      num_files_viewed_limit: default_abridged_num_files_viewed_limit(),
      num_terminal_commands_limit: default_abridged_num_terminal_commands_limit(),
    }
  }
}

impl AbridgedHistoryParams {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.total_chars_limit == 0 {
      anyhow::bail!("history_summary.abridged_history_params.total_chars_limit 不能为 0");
    }
    Ok(())
  }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct LoggingConfig {
  #[serde(default = "default_logging_filter")]
  pub filter: String,
  #[serde(default)]
  pub dump_chat_stream_body: bool,
}

impl Default for LoggingConfig {
  fn default() -> Self {
    Self {
      filter: default_logging_filter(),
      dump_chat_stream_body: false,
    }
  }
}

impl LoggingConfig {
  pub fn validate(&self) -> anyhow::Result<()> {
    if self.filter.trim().is_empty() {
      anyhow::bail!("logging.filter 不能为空");
    }
    tracing_subscriber::EnvFilter::try_new(self.filter.trim())
      .context("logging.filter 不是合法 tracing filter (EnvFilter 语法)")?;
    Ok(())
  }
}

pub fn init_tracing(logging: &LoggingConfig) -> anyhow::Result<()> {
  let filter = tracing_subscriber::EnvFilter::try_new(logging.filter.trim())
    .context("logging.filter 不是合法 tracing filter (EnvFilter 语法)")?;
  tracing_subscriber::fmt()
    .with_env_filter(filter)
    .with_target(false)
    .compact()
    .init();
  Ok(())
}
